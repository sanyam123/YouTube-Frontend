import React, { useState, useEffect, useRef } from 'react';
import './App.css';
import SearchBar from './components/SearchBar';
import TranscriptViewer from './components/TranscriptViewer';
import Header from './components/Header';
import Footer from './components/Footer';
import LoadingSpinner from './components/LoadingSpinner';
import VideoInfo from './components/VideoInfo';
import TakeawaysViewer from './components/TakeawaysViewer';
import axios from 'axios';
import HowItWorks from './components/HowItWorks';
import ErrorMessage from './components/ErrorMessage';

function App() {
  const [videoUrl, setVideoUrl] = useState('');
  const [transcript, setTranscript] = useState('');
  const [videoDetails, setVideoDetails] = useState(null);
  const [rawChapterizedTranscript, setRawChapterizedTranscript] = useState([]);
  const [enhancedChapterizedTranscript, setEnhancedChapterizedTranscript] = useState([]);
  const [chapterEnhancementStatus, setChapterEnhancementStatus] = useState({});
  const [chapterAnalyses, setChapterAnalyses] = useState([]);
  const [chapterAnalysisStatus, setChapterAnalysisStatus] = useState({});
  const [summary, setSummary] = useState('');
  const [worthWatching, setWorthWatching] = useState('');
  const [loading, setLoading] = useState(false);
  const [enhancingTranscript, setEnhancingTranscript] = useState(false);
  const [generatingAnalyses, setGeneratingAnalyses] = useState(false);
  const [processingBatch, setProcessingBatch] = useState(false);
  const [error, setError] = useState('');
  const [activeTab, setActiveTab] = useState(null);
  const [activeChapter, setActiveChapter] = useState(0);
  const [dataFetched, setDataFetched] = useState(false);
  const [lastAnalyzedChapter, setLastAnalyzedChapter] = useState(-1);
  const [connectionStatus, setConnectionStatus] = useState(null);
  const [transcriptLanguage, setTranscriptLanguage] = useState('en');
  const [transcriptLanguageName, setTranscriptLanguageName] = useState('English');
  const [isAutoGenerated, setIsAutoGenerated] = useState(false);
  const [requiresTranslation, setRequiresTranslation] = useState(false);
  
  // New state variables for non-chaptered videos
  const [hasChapters, setHasChapters] = useState(true);
  const [noChapterEnhancedTranscript, setNoChapterEnhancedTranscript] = useState('');
  const [noChapterAnalysis, setNoChapterAnalysis] = useState({
    summary: '',
    takeaways: '',
    quotes: ''
  });
  const [processingNoChapterTranscript, setProcessingNoChapterTranscript] = useState(false);
  const [loadingNoChapterTranscript, setLoadingNoChapterTranscript] = useState(false);
  const [loadingNoChapterAnalysis, setLoadingNoChapterAnalysis] = useState(false);
  const [noChapterTranscriptChunks, setNoChapterTranscriptChunks] = useState([]);
  const [noChapterAnalysisChunks, setNoChapterAnalysisChunks] = useState([]);
  
  // SAFEGUARD 1: Add ref to track if processing has already been initiated
  const noChapterProcessingInitiated = useRef(false);
  // SAFEGUARD 2: Add ref to track the current video ID being processed
  const currentVideoId = useRef(null);
  // NEW: Add state to prevent repeated processing
  const [processingInitiated, setProcessingInitiated] = useState(false);

  const backendUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000';
  console.log('Using backend URL:', backendUrl);
  
  const BATCH_SIZE = 3;
  const CHUNK_SIZE_MINUTES = 10; // Size of chunks for non-chaptered videos in minutes

  // Extract video ID from URL - helper function
  const extractVideoId = (url) => {
    const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
    const match = url.match(regExp);
    return (match && match[7].length === 11) ? match[7] : null;
  };

  // Handle URL parameters when component mounts
  useEffect(() => {
    const handleUrlParameters = () => {
      const params = new URLSearchParams(window.location.search);
      const videoId = params.get('videoId') || params.get('v');
      
      if (videoId) {
        console.log('Video ID detected in URL:', videoId);
        const fullYoutubeUrl = `https://www.youtube.com/watch?v=${videoId}`;
        setVideoUrl(fullYoutubeUrl);
        fetchTranscriptWithUrl(fullYoutubeUrl);
      }
    };
    
    testBackendConnection().then(connected => {
      if (connected) {
        handleUrlParameters();
      }
    });
  }, []); // Empty dependency array to run only once

  // Test backend connection
  const testBackendConnection = async () => {
    try {
      setConnectionStatus('Testing connection to backend...');
      
      const rootResponse = await fetch(`${backendUrl}`);
      console.log('Root endpoint status:', rootResponse.status);
      
      if (!rootResponse.ok) {
        const errorText = await rootResponse.text();
        console.error('Root endpoint error:', errorText);
        setConnectionStatus(`Connection error: ${rootResponse.status} - ${errorText}`);
        return false;
      }
      
      try {
        const corsResponse = await fetch(`${backendUrl}/api/cors-test`);
        console.log('CORS test status:', corsResponse.status);
        
        if (corsResponse.ok) {
          const corsData = await corsResponse.json();
          console.log('CORS test response:', corsData);
        }
      } catch (corsError) {
        console.warn('CORS test failed, but continuing:', corsError);
      }
      
      setConnectionStatus('Connection to backend successful');
      return true;
    } catch (error) {
      console.error('Backend connection error:', error);
      setConnectionStatus(`Failed to connect to backend: ${error.message}`);
      return false;
    }
  };

  // Function to enhance specific chapters - UPDATED
  const enhanceChapters = async (chaptersToEnhance) => {
    // If no chapters to enhance, return immediately
    if (!chaptersToEnhance || chaptersToEnhance.length === 0) {
      return true;
    }
    
    try {
      const updatedStatus = { ...chapterEnhancementStatus };
      
      // Skip chapters that are already completed
      const chaptersToProcess = chaptersToEnhance.filter(chapter => 
        updatedStatus[chapter.index] !== 'completed'
      );
      
      // If no chapters need processing, return immediately
      if (chaptersToProcess.length === 0) {
        return true;
      }
      
      // Mark them as enhancing (if not already)
      chaptersToProcess.forEach(chapter => {
        if (updatedStatus[chapter.index] !== 'enhancing') {
          updatedStatus[chapter.index] = 'enhancing';
        }
      });
      setChapterEnhancementStatus(updatedStatus);
      
      console.log('Enhancing chapters - Request payload:', { 
        chapters: chaptersToProcess.map(ch => ({
          title: ch.chapter.title,
          content: ch.chapter.content,
        }))
      });
      
      const response = await axios.post(`${backendUrl}/api/enhance-chapters`, { 
        chapters: chaptersToProcess.map(ch => ({
          title: ch.chapter.title,
          content: ch.chapter.content,
        }))
      }, {
        headers: {
          'Content-Type': 'application/json',
        },
        timeout: 60000
      });
      
      console.log('Enhance chapters response:', response.data);
      
      const data = response.data;
      
      const newEnhancedChapters = [...enhancedChapterizedTranscript];
      
      data.enhancedChapters.forEach((enhancedChapter, idx) => {
        const chapterIndex = chaptersToProcess[idx].index;
        newEnhancedChapters[chapterIndex] = {
          ...rawChapterizedTranscript[chapterIndex],
          content: enhancedChapter.enhancedContent
        };
        updatedStatus[chapterIndex] = 'completed';
      });
      
      setEnhancedChapterizedTranscript(newEnhancedChapters);
      setChapterEnhancementStatus(updatedStatus);
      
      return true;
    } catch (error) {
      console.error('Error enhancing chapters - Full error:', error);
      console.error('Error response:', error.response);
      
      const updatedStatus = { ...chapterEnhancementStatus };
      chaptersToEnhance.forEach(chapter => {
        updatedStatus[chapter.index] = 'failed';
      });
      setChapterEnhancementStatus(updatedStatus);
      
      return false;
    }
  };

  // Function to generate analyses for a batch of chapters
  const generateBatchAnalyses = async (startIndex, endIndex) => {
    try {
      setGeneratingAnalyses(true);
      
      console.log(`Processing batch - Start: ${startIndex}, End: ${endIndex}`);
      
      // Process chapters in sequence to maintain context
      for (let i = startIndex; i <= endIndex; i++) {
        const chapter = rawChapterizedTranscript[i];
        
        // Update the status to pending for just this chapter
        setChapterAnalysisStatus(prev => ({
          ...prev,
          [i]: 'pending'
        }));
        
        // Get context from previously analyzed chapters
        const contextSummaries = [];
        for (let j = 0; j < i; j++) {
          const previousAnalysis = chapterAnalyses[j];
          if (previousAnalysis && previousAnalysis.summary) {
            contextSummaries.push({
              index: j,
              title: rawChapterizedTranscript[j].title,
              summary: previousAnalysis.summary
            });
          }
        }
        
        try {
          // Make API call for this specific chapter
          const response = await axios.post(`${backendUrl}/api/generate-sequential-analyses`, {
            chapters: rawChapterizedTranscript.slice(0, i + 1),
            startIndex: i,
            endIndex: i
          }, {
            headers: { 'Content-Type': 'application/json' },
            timeout: 60000
          });
          
          // Check if we got a valid response with chapter analysis
          if (response.data.chapterAnalyses && response.data.chapterAnalyses.length > 0) {
            const newAnalysis = response.data.chapterAnalyses[0];
            
            // Important: Update state immediately for this single chapter
            setChapterAnalyses(prev => {
              const updated = [...prev];
              updated[i] = {
                ...newAnalysis,
                chapterIndex: i // Ensure correct index
              };
              return updated;
            });
            
            // Update status to completed for this chapter
            setChapterAnalysisStatus(prev => ({
              ...prev,
              [i]: 'completed'
            }));
            
            console.log(`Chapter ${i} analysis completed and state updated`);
          }
        } catch (chapterError) {
          console.error(`Error analyzing chapter ${i}:`, chapterError);
          
          // Mark just this chapter as failed
          setChapterAnalysisStatus(prev => ({
            ...prev,
            [i]: 'failed'
          }));
        }
      }
      
      // Return null since we've been updating state incrementally
      return null;
    } catch (error) {
      console.error('Error generating analyses - Full error:', error);
      console.error('Error response:', error.response);
      return null;
    }
  };

  // Function to process all chapters in batches
  const processAllChaptersInBatches = async (startFromIndex = 0) => {
    if (processingBatch || !rawChapterizedTranscript.length) return;
  
    setProcessingBatch(true);
    setGeneratingAnalyses(true);
    
    try {
      // Use a smaller batch size for faster incremental updates
      const SMALLER_BATCH_SIZE = 2;
      
      for (let i = startFromIndex; i < rawChapterizedTranscript.length; i += SMALLER_BATCH_SIZE) {
        const batchEndIndex = Math.min(i + SMALLER_BATCH_SIZE - 1, rawChapterizedTranscript.length - 1);
        console.log(`Starting batch from ${i} to ${batchEndIndex}`);
        
        // This call will now update state incrementally for each chapter
        await generateBatchAnalyses(i, batchEndIndex);
        
        // Update the last analyzed chapter
        setLastAnalyzedChapter(batchEndIndex);
      }
    } catch (error) {
      console.error('Error processing batches:', error);
    } finally {
      setProcessingBatch(false);
      setGeneratingAnalyses(false);
    }
  };

  // Effect to handle initial enhancement and start batch processing for videos with and without chapters
  // UPDATED: Decoupled enhancement from analysis
  useEffect(() => {
    // Skip if data hasn't been fetched yet or if processing has already been initiated
    if (!dataFetched || !videoDetails || processingInitiated) return;
    
    const videoId = extractVideoId(videoUrl);
    console.log('Current video ID:', videoId);
    
    const processVideo = async () => {
      setProcessingInitiated(true); // Set flag to prevent reprocessing
      
      if (hasChapters) {
        // Process videos with chapters
        if (rawChapterizedTranscript.length > 0) {
          try {
            // Step 1: Start enhancing the first 2 chapters immediately
            if (!enhancingTranscript) {
              setEnhancingTranscript(true);
              const chaptersToEnhance = rawChapterizedTranscript
                .slice(0, Math.min(2, rawChapterizedTranscript.length))
                .map((chapter, index) => ({ chapter, index }));
              
              if (chaptersToEnhance.length > 0) {
                // Only wait for enhancement of initial chapters
                await enhanceChapters(chaptersToEnhance);
                setEnhancingTranscript(false);
              }
            }
            
            // Step 2: Start analysis process separately (don't await it)
            processAllChaptersInBatches(0);
            
          } catch (error) {
            console.error('Error processing initial chapters:', error);
            setEnhancingTranscript(false);
          }
        }
      } else {
        // Processing for non-chaptered videos remains the same
        if (
          !processingNoChapterTranscript && 
          !noChapterProcessingInitiated.current && 
          noChapterTranscriptChunks.length === 0 &&
          videoDetails?.transcriptData?.length > 0
        ) {
          console.log('Starting to process video without chapters');
          
          // Mark processing as initiated
          noChapterProcessingInitiated.current = true;
          
          setLoadingNoChapterTranscript(true);
          setLoadingNoChapterAnalysis(true);
          
          // Introduce a small delay to ensure state updates have propagated
          setTimeout(() => {
            processNoChapterTranscript();
          }, 100);
        }
      }
    };
    
    processVideo();
  }, [dataFetched, videoDetails, hasChapters, rawChapterizedTranscript.length, videoUrl]);

  // NEW: Function to split transcript into chunks for non-chaptered videos
  const splitTranscriptIntoChunks = (transcriptData) => {
    if (!transcriptData || transcriptData.length === 0) {
      console.error('No transcript data available to split into chunks');
      return [];
    }
    
    console.log('Splitting transcript into chunks. Length:', transcriptData.length);
    
    const chunks = [];
    let currentChunk = [];
    let currentChunkDuration = 0;
    const maxChunkDuration = CHUNK_SIZE_MINUTES * 60; // Convert to seconds
    
    for (const segment of transcriptData) {
      currentChunk.push(segment);
      currentChunkDuration += segment.duration || 0;
      
      if (currentChunkDuration >= maxChunkDuration) {
        // Calculate chunk text
        const chunkText = currentChunk
          .map(item => item.text || '')
          .join(' ')
          .replace(/\s+/g, ' ');
        
        chunks.push({
          startTime: currentChunk[0].offset || 0,
          endTime: (currentChunk[currentChunk.length - 1].offset || 0) + (currentChunk[currentChunk.length - 1].duration || 0),
          content: chunkText,
          index: chunks.length
        });
        
        // Start a new chunk but keep last 2 minutes (approximately) for context
        const contextDuration = 120; // 2 minutes in seconds
        let contextSegments = [];
        let tempDuration = 0;
        
        // Loop backwards to get ~2 minutes of context
        for (let i = currentChunk.length - 1; i >= 0; i--) {
          if (tempDuration < contextDuration) {
            contextSegments.unshift(currentChunk[i]);
            tempDuration += currentChunk[i].duration || 0;
          } else {
            break;
          }
        }
        
        currentChunk = contextSegments;
        currentChunkDuration = tempDuration;
      }
    }
    
    // Add any remaining segments as the last chunk
    if (currentChunk.length > 0) {
      const chunkText = currentChunk
        .map(item => item.text || '')
        .join(' ')
        .replace(/\s+/g, ' ');
      
      chunks.push({
        startTime: currentChunk[0].offset || 0,
        endTime: (currentChunk[currentChunk.length - 1].offset || 0) + (currentChunk[currentChunk.length - 1].duration || 0),
        content: chunkText,
        index: chunks.length
      });
    }
    
    console.log(`Split transcript into ${chunks.length} chunks`);
    return chunks;
  };

  // NEW: Function to process a transcript chunk for non-chaptered videos
  const processTranscriptChunk = async (chunk, previousContext) => {
    try {
      console.log(`Processing transcript chunk ${chunk.index}`);
      
      const response = await axios.post(`${backendUrl}/api/process-transcript-chunk`, {
        transcriptChunk: chunk.content,
        previousContext: previousContext,
        chunkIndex: chunk.index
      }, {
        headers: { 'Content-Type': 'application/json' },
        timeout: 60000
      });
      
      console.log(`Chunk ${chunk.index} processed successfully`);
      return response.data;
    } catch (error) {
      console.error(`Error processing chunk ${chunk.index}:`, error);
      return null;
    }
  };

  // NEW: Function to process non-chaptered video transcript
  // SAFEGUARD 8: Improved processNoChapterTranscript with additional checks
  const processNoChapterTranscript = async () => {
    // SAFEGUARD 9: Multiple early-return conditions
    if (processingNoChapterTranscript) {
      console.log("Already processing transcript, skipping");
      return;
    }
    
    if (noChapterTranscriptChunks.length > 0) {
      console.log("Chunks already exist, skipping processing");
      return;
    }
    
    if (!transcript) {
      console.log("Cannot process: no transcript available");
      return;
    }
    
    console.log("Starting non-chaptered transcript processing");
    setProcessingNoChapterTranscript(true);
    
    try {
      // Verify videoDetails and transcriptData
      if (!videoDetails) {
        console.error("No videoDetails available");
        return;
      }
      
      // Extract transcriptData from the response
      const transcriptData = videoDetails.transcriptData;
      
      if (!transcriptData || !Array.isArray(transcriptData)) {
        console.error("Missing or invalid transcriptData:", transcriptData);
        return;
      }
      
      console.log("TranscriptData available, items:", transcriptData.length);
      
      // Split transcript into chunks
      const chunks = splitTranscriptIntoChunks(transcriptData);
      
      // SAFEGUARD 10: Check for valid chunks before continuing
      if (chunks.length === 0) {
        console.error('Failed to split transcript into chunks');
        return;
      }
      
      // SAFEGUARD 11: Set chunks in state before processing to prevent duplicate processing
      setNoChapterTranscriptChunks(chunks);
      
      console.log(`Split transcript into ${chunks.length} chunks`);
      
      // Process chunks sequentially to maintain context
      let previousContext = '';
      let enhancedTranscriptText = '';
      let aggregatedSummary = '';
      let aggregatedTakeaways = '';
      let aggregatedQuotes = '';
      
      for (let i = 0; i < chunks.length; i++) {
        // Update loading states for UI feedback
        setLoadingNoChapterTranscript(true);
        setLoadingNoChapterAnalysis(true);
        
        const result = await processTranscriptChunk(chunks[i], previousContext);
        
        if (result) {
          // Update enhanced transcript
          const updatedChunks = [...chunks]; // SAFEGUARD 12: Use original chunks array here
          updatedChunks[i] = {
            ...updatedChunks[i],
            enhancedContent: result.enhancedTranscript,
            processed: true
          };
          setNoChapterTranscriptChunks(updatedChunks);
          
          // Append to full enhanced transcript
          enhancedTranscriptText += (enhancedTranscriptText ? '\n\n' : '') + result.enhancedTranscript;
          setNoChapterEnhancedTranscript(enhancedTranscriptText);
          
          // Update analysis
          const updatedAnalysisChunks = [...noChapterAnalysisChunks];
          while (updatedAnalysisChunks.length <= i) {
            updatedAnalysisChunks.push(null); // SAFEGUARD 13: Ensure array has enough slots
          }
          
          updatedAnalysisChunks[i] = {
            index: i,
            ...result.analysis,
            processed: true
          };
          setNoChapterAnalysisChunks(updatedAnalysisChunks);
          
          // Aggregate analysis data
          aggregatedSummary += (aggregatedSummary ? '\n\n' : '') + result.analysis.summary;
          aggregatedTakeaways += (aggregatedTakeaways ? '\n\n' : '') + result.analysis.takeaways;
          
          if (result.analysis.quotes) {
            aggregatedQuotes += (aggregatedQuotes ? '\n\n' : '') + result.analysis.quotes;
          }
          
          setNoChapterAnalysis({
            summary: aggregatedSummary,
            takeaways: aggregatedTakeaways,
            quotes: aggregatedQuotes
          });
          
          // Update context for next chunk
          previousContext = result.contextForNextChunk;
        } else {
          console.error(`Failed to process chunk ${i}`);
        }
        
        // Update loading indicators after each chunk is processed
        setLoadingNoChapterTranscript(false);
        setLoadingNoChapterAnalysis(false);
      }
      
      console.log('Finished processing all transcript chunks');
      
    } catch (error) {
      console.error('Error processing non-chaptered transcript:', error);
    } finally {
      setProcessingNoChapterTranscript(false);
      setLoadingNoChapterTranscript(false);
      setLoadingNoChapterAnalysis(false);
    }
  };

  // Handle chapter click with transcript enhancement - UPDATED
  const handleChapterClick = async (index) => {
    setActiveChapter(index);
    
    // If this chapter hasn't been enhanced yet and isn't currently being enhanced
    if (
      hasChapters &&
      index >= 0 && 
      index < rawChapterizedTranscript.length && 
      chapterEnhancementStatus[index] !== 'completed' && 
      chapterEnhancementStatus[index] !== 'enhancing'
    ) {
      // Set local enhancement status immediately to prevent double processing
      const updatedStatus = { ...chapterEnhancementStatus };
      updatedStatus[index] = 'enhancing';
      setChapterEnhancementStatus(updatedStatus);
      
      try {
        // Process this chapter independently from the batch processing
        await enhanceChapters([{ 
          chapter: rawChapterizedTranscript[index], 
          index 
        }]);
      } catch (error) {
        console.error(`Error enhancing chapter ${index}:`, error);
        // Reset status on error
        const failedStatus = { ...chapterEnhancementStatus };
        failedStatus[index] = 'failed';
        setChapterEnhancementStatus(failedStatus);
      }
    }
  };

  // Helper function for fetching transcript with a specific URL
  const fetchTranscriptWithUrl = async (url) => {
    if (!url.trim()) {
      setError('Please enter a YouTube video URL');
      return;
    }
    
    try {
      setLoading(true);
      setError('');
      setDataFetched(false);
      setVideoDetails(null);
      setTranscript('');
      setRawChapterizedTranscript([]);
      setEnhancedChapterizedTranscript([]);
      setChapterEnhancementStatus({});
      setChapterAnalyses([]);
      setChapterAnalysisStatus({});
      setSummary('');
      setWorthWatching('');
      setActiveTab('transcript');
      setActiveChapter(0);
      setEnhancingTranscript(false);
      setGeneratingAnalyses(false);
      setLastAnalyzedChapter(-1);
      setTranscriptLanguage('en');
      setTranscriptLanguageName('English');
      setIsAutoGenerated(false);
      setRequiresTranslation(false);
      
      // Reset processing flags
      setProcessingInitiated(false);
      
      // Reset non-chaptered video states
      setHasChapters(true);
      setNoChapterEnhancedTranscript('');
      setNoChapterAnalysis({ summary: '', takeaways: '', quotes: '' });
      setProcessingNoChapterTranscript(false);
      setLoadingNoChapterTranscript(false);
      setLoadingNoChapterAnalysis(false);
      setNoChapterTranscriptChunks([]);
      setNoChapterAnalysisChunks([]);
      
      // SAFEGUARD 14: Reset the refs that track processing state
      noChapterProcessingInitiated.current = false;
      currentVideoId.current = extractVideoId(url);
      
      console.log('Fetching transcript for URL:', url);
      console.log('Using backend URL:', `${backendUrl}/api/video-data`);
      
      try {
        // Try using Axios first
        const response = await axios.get(`${backendUrl}/api/video-data`, {
          params: { url: url },
          timeout: 60000,
          headers: { 'Content-Type': 'application/json' }
        });
        
        console.log('Fetch transcript response status:', response.status);
        console.log('Fetch transcript response data:', response.data);
        
        const data = response.data;
        
        // Set has chapters flag
        setHasChapters(data.hasChapters);
        
        setVideoDetails(data.videoDetails);
        setTranscript(data.transcript);
        
        // Store the full transcript data for non-chaptered processing
        if (data.transcriptData) {
          // Ensure videoDetails includes transcriptData for non-chaptered processing
          setVideoDetails(prev => ({
            ...prev,
            transcriptData: data.transcriptData
          }));
        }
        
        if (data.hasChapters) {
          // Process chapters as before
          setRawChapterizedTranscript(data.organizedTranscript);
          setEnhancedChapterizedTranscript(data.organizedTranscript.map(() => null));
          
          const initialStatus = {};
          data.organizedTranscript.forEach((_, index) => {
            initialStatus[index] = 'pending';
          });
          setChapterEnhancementStatus(initialStatus);
        } else {
          // For non-chaptered videos, set empty chapter arrays
          setRawChapterizedTranscript([]);
          setEnhancedChapterizedTranscript([]);
        }
        
        // Set language information
        setTranscriptLanguage(data.transcriptLanguage || 'en');
        setTranscriptLanguageName(data.transcriptLanguageName || 'English');
        setIsAutoGenerated(data.isAutoGenerated || false);
        setRequiresTranslation(data.requiresTranslation || false);
        
        setDataFetched(true);
      } catch (axiosError) {
        console.error('Axios request failed - Falling back to fetch', axiosError);
        
        // Fallback to fetch if axios fails
        const fetchResponse = await fetch(`${backendUrl}/api/video-data?url=${encodeURIComponent(url)}`);
        console.log('Fetch API response status:', fetchResponse.status);
        
        if (!fetchResponse.ok) {
          const errorText = await fetchResponse.text();
          console.error('Fetch API error text:', errorText);
          throw new Error(errorText || 'Failed to fetch video data');
        }
        
        const data = await fetchResponse.json();
        console.log('Fetch API response data:', data);
        
        // Set has chapters flag
        setHasChapters(data.hasChapters);
        
        setVideoDetails(data.videoDetails);
        setTranscript(data.transcript);
        
        // Store the full transcript data for non-chaptered processing
        if (data.transcriptData) {
          // Ensure videoDetails includes transcriptData for non-chaptered processing
          setVideoDetails(prev => ({
            ...prev,
            transcriptData: data.transcriptData
          }));
        }
        
        if (data.hasChapters) {
          // Process chapters as before
          setRawChapterizedTranscript(data.organizedTranscript);
          setEnhancedChapterizedTranscript(data.organizedTranscript.map(() => null));
          const initialStatus = {};
          data.organizedTranscript.forEach((_, index) => {
            initialStatus[index] = 'pending';
          });
          setChapterEnhancementStatus(initialStatus);
        } else {
          // For non-chaptered videos, set empty chapter arrays
          setRawChapterizedTranscript([]);
          setEnhancedChapterizedTranscript([]);
        }
        
        // Set language information
        setTranscriptLanguage(data.transcriptLanguage || 'en');
        setTranscriptLanguageName(data.transcriptLanguageName || 'English');
        setIsAutoGenerated(data.isAutoGenerated || false);
        setRequiresTranslation(data.requiresTranslation || false);
        
        setDataFetched(true);
      }
    } catch (err) {
      console.error('Error fetching transcript - Full error:', err);
      if (err.response) {
        console.error('Error response data:', err.response.data);
        console.error('Error response status:', err.response.status);
        console.error('Error response headers:', err.response.headers);
        setError(err.response.data?.message || 'An error occurred while fetching the video data');
      } else if (err.request) {
        console.error('Error request (no response received):', err.request);
        setError('No response received from server. Please check your connection.');
      } else {
        console.error('Error message:', err.message);
        setError(err.message || 'An error occurred while fetching the video data');
      }
      setVideoDetails(null);
      setDataFetched(false);
      
      // SAFEGUARD 15: Reset processing state on error
      noChapterProcessingInitiated.current = false;
      setProcessingInitiated(false);
    } finally {
      setLoading(false);
    }
  };

  // Main function to fetch transcript (uses the helper function)
  const fetchTranscript = () => {
    fetchTranscriptWithUrl(videoUrl);
  };

  const analyzeWorthWatching = async () => {
    if (!transcript) {
      setError('Please fetch a transcript first');
      return;
    }
    
    try {
      setLoading(true);
      setError('');
      
      const response = await axios.post(`${backendUrl}/api/analyze`, 
        { transcript },
        {
          headers: { 'Content-Type': 'application/json' },
          timeout: 60000
        }
      );
      
      console.log('Analyze response:', response.data);
      
      setWorthWatching(response.data.analysis);
      setActiveTab('analysis');
    } catch (err) {
      console.error('Error analyzing - Full error:', err);
      if (err.response) {
        console.error('Error response data:', err.response.data);
        setError(err.response.data?.message || 'An error occurred while analyzing the video');
      } else {
        setError(err.message || 'An error occurred while analyzing the video');
      }
    } finally {
      setLoading(false);
    }
  };

  // Component for displaying non-chaptered transcript
  const NoChapterTranscriptViewer = ({ transcript, loading }) => {
    if (loading) {
      return (
        <div className="loading-container">
          <LoadingSpinner />
          <p>Fetching Enhanced Transcript...</p>
        </div>
      );
    }
    
    if (!transcript) {
      return (
        <div className="empty-state">
          <p>Transcript will appear here as it's processed.</p>
        </div>
      );
    }
    
    return (
      <div className="no-chapter-transcript">
        {transcript.split('\n\n').map((paragraph, index) => (
          <p key={index}>{paragraph}</p>
        ))}
      </div>
    );
  };

  // Component for displaying non-chaptered analysis
  // Updated Component for displaying non-chaptered analysis
const NoChapterAnalysisViewer = ({ analysis, loading }) => {
  if (loading) {
    return (
      <div className="loading-container">
        <LoadingSpinner />
        <p>Fetching Smart Insights...</p>
      </div>
    );
  }
  
  if (!analysis.summary && !analysis.takeaways) {
    return (
      <div className="empty-state">
        <p>Analysis will appear here as it's processed.</p>
      </div>
    );
  }
  
  // Function to format and clean text content
  const formatText = (text) => {
    if (!text) return null;
    
    // Clean up the text by removing unwanted symbols
    let cleanedText = text
      .replace(/#+\s*$/gm, '') // Remove hash symbols at the end of lines
      .replace(/###/g, '') // Remove all ### markers
      .replace(/^\s*-\s*/gm, '') // Remove leading dashes with spaces
      .replace(/\*{2,}/g, '') // Remove multiple asterisks
      .replace(/_{3,}/g, '') // Remove multiple underscores
      .trim();
    
    // Split into paragraphs and map to JSX elements
    return cleanedText
      .split('\n\n')
      .filter(paragraph => paragraph.trim() !== '')
      .map((paragraph, index) => {
        // Check if this appears to be a list item from formatting
        if (paragraph.trim().match(/^[-•*]|\d+\./)) {
          // For list items, return as a list item
          return <li key={index}>{paragraph.replace(/^[-•*]|\d+\./, '').trim()}</li>;
        }
        
        // Regular paragraph
        return <p key={index}>{paragraph}</p>;
      });
  };
  
  // Function to properly format takeaways as a list
  const formatTakeaways = (takeaways) => {
    if (!takeaways) return null;
    
    // Clean up the content
    const cleanedContent = takeaways
      .replace(/#+\s*$/gm, '')  // Remove hash symbols at the end of lines
      .replace(/###/g, '')      // Remove all ### markers
      .trim();
    
    // Split into lines
    const lines = cleanedContent.split('\n')
      .filter(line => line.trim() !== '');
    
    // Check if content appears to be a list
    const isList = lines.some(line => line.trim().match(/^\s*[-•*]/));
    
    if (isList) {
      // Format as a bulleted list
      return (
        <ul className="takeaways-list">
          {lines.map((line, index) => {
            // Remove the bullet point if present and trim
            const cleanLine = line.replace(/^\s*[-•*]\s*/, '').trim();
            return <li key={index}>{cleanLine}</li>;
          })}
        </ul>
      );
    } else {
      // Format as paragraphs
      return lines.map((line, index) => <p key={index}>{line}</p>);
    }
  };
  
  return (
    <div className="no-chapter-analysis">
      {analysis.summary && (
        <div className="summary-section">
          <h3>Summary</h3>
          <div className="summary-content">
            {formatText(analysis.summary)}
          </div>
        </div>
      )}
      
      {analysis.takeaways && (
        <div className="takeaways-section">
          <h3>Key Takeaways</h3>
          <div className="takeaways-content">
            {formatTakeaways(analysis.takeaways)}
          </div>
        </div>
      )}
      
      {analysis.quotes && (
        <div className="quotes-section">
          <h3>Notable Quotes</h3>
          <div className="quotes-content">
            {formatText(analysis.quotes)}
          </div>
        </div>
      )}
    </div>
  );
};

  return (
    <div className="App app-container">
      <Header className="app-header" />
      
      <main className="container-wide app-main">
        {/* {connectionStatus && (
          <div className={`connection-status ${connectionStatus.includes('error') || connectionStatus.includes('failed') ? 'error' : 'success'}`}>
            {connectionStatus}
          </div>
        )} */}
        
        <SearchBar 
          videoUrl={videoUrl} 
          setVideoUrl={setVideoUrl} 
          onSearch={fetchTranscript} 
        />
        
        {error && (
          <ErrorMessage 
            error={error} 
            onRetry={() => videoUrl ? fetchTranscript() : null} 
          />
        )}
        
        {loading ? (
          <LoadingSpinner />
        ) : (
          <>
            {videoDetails && <VideoInfo videoDetails={videoDetails} />}
            {!dataFetched && !loading && <HowItWorks />}
            
            {requiresTranslation && (
              <div className="language-notification">
                <p>
                  <strong>Note:</strong> This video's transcript is in {transcriptLanguageName}
                  {isAutoGenerated && " (auto-generated)"}.
                </p>
              </div>
            )}
            
            {!hasChapters && dataFetched && (
              <div className="no-chapters-notification">
                <p>
                  <strong>Note:</strong> This video doesn't have chapters. We'll process the transcript in sequential sections.
                </p>
              </div>
            )}
            
            {dataFetched && (
              <>
                <div className="button-container tab-container">
                  <button 
                    onClick={() => setActiveTab('transcript')}
                    className={activeTab === 'transcript' ? 'active' : ''}
                  >
                    Enhanced Transcript
                  </button>
                  <button 
                    onClick={() => setActiveTab('takeaways')}
                    className={activeTab === 'takeaways' ? 'active' : ''}
                  >
                    Smart Insights
                  </button>
                  <button 
                    onClick={() => setActiveTab('analysis')}
                    className={activeTab === 'analysis' ? 'active' : ''}
                    disabled={loading}
                  >
                    Worth Watching?
                  </button>
                </div>
                
                {activeTab && (
                  <div className="content-container-wrapper">
                    <div className="content-container">
                      {activeTab === 'transcript' && hasChapters && (
                        <TranscriptViewer 
                          rawChapterizedTranscript={rawChapterizedTranscript}
                          enhancedChapterizedTranscript={enhancedChapterizedTranscript} 
                          chapterEnhancementStatus={chapterEnhancementStatus}
                          activeChapter={activeChapter}
                          onChapterClick={handleChapterClick}
                          videoDetails={videoDetails}
                        />
                      )}
                      
                      {activeTab === 'transcript' && !hasChapters && (
                        <NoChapterTranscriptViewer
                          transcript={noChapterEnhancedTranscript}
                          loading={loadingNoChapterTranscript}
                        />
                      )}
                      
                      {activeTab === 'takeaways' && hasChapters && (
                        <TakeawaysViewer
                          chapterAnalyses={chapterAnalyses}
                          chapterAnalysisStatus={chapterAnalysisStatus}
                          rawChapterizedTranscript={rawChapterizedTranscript}
                          activeChapter={activeChapter}
                          onChapterClick={handleChapterClick}
                          generatingAnalyses={generatingAnalyses}
                        />
                      )}
                      
                      {activeTab === 'takeaways' && !hasChapters && (
                        <NoChapterAnalysisViewer
                          analysis={noChapterAnalysis}
                          loading={loadingNoChapterAnalysis}
                        />
                      )}
                      
                      {activeTab === 'analysis' && (
                        <div className="generating-analysis">
                          <h3>
                            Coming Soon!
                          </h3>
                          <p>
                            We're working on an exciting new feature that will help you decide if a video is worth your time. 
                            Stay tuned for the update!
                          </p>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </>
            )}
          </>
        )}
      </main>
      
      <Footer className="app-footer" />
    </div>
  );
}

export default App;